# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g4PlJQibrR5SA6oOb0Lhsk_86XogxLlE
"""

# Install required packages
!pip install requests pandas numpy plotly -q

import requests
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import time

print("üöÄ Crypto Screening App Initialized!")
print("Fetching and analyzing crypto data...")

class CryptoScreener:
    def __init__(self):
        self.base_url = "https://api.coingecko.com/api/v3"
        self.session = requests.Session()

    def get_top_cryptos(self, limit=200):
        """Get top cryptocurrencies by market cap"""
        url = f"{self.base_url}/coins/markets"
        params = {
            'vs_currency': 'usd',
            'order': 'market_cap_desc',
            'per_page': limit,
            'page': 1,
            'sparkline': False,
            'price_change_percentage': '1h,24h,7d,30d'
        }

        try:
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching data: {e}")
            return []

    def calculate_volume_ratios(self, df):
        """Calculate volume to market cap ratios and other metrics"""
        df = df.copy()

        # Calculate volume to market cap ratio
        df['volume_mcap_ratio'] = df['total_volume'] / df['market_cap']

        # Calculate normalized scores (0-100)
        df['volume_24h_score'] = self.normalize_score(df['total_volume'])
        df['volume_ratio_score'] = self.normalize_score(df['volume_mcap_ratio'])

        # Calculate overall score (weighted)
        df['overall_score'] = (
                df['volume_24h_score'] * 0.6 +
                df['volume_ratio_score'] * 0.4
            )

        return df

    def normalize_score(self, series):
        """Normalize series to 0-100 scale"""
        if series.max() == series.min():
            return 50  # Default middle score if all values are same
        return ((series - series.min()) / (series.max() - series.min())) * 100

    def get_historical_volume(self, coin_id, days=30):
        """Get historical volume data for a specific coin"""
        url = f"{self.base_url}/coins/{coin_id}/market_chart"
        params = {
            'vs_currency': 'usd',
            'days': days,
            'interval': 'daily'
        }

        try:
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            # Extract volumes and timestamps
            volumes = [entry[1] for entry in data['total_volumes']]
            timestamps = [entry[0] for entry in data['total_volumes']]

            return volumes, timestamps
        except Exception as e:
            print(f"Error fetching historical data for {coin_id}: {e}")
            return [], []

def run_screener():
    screener = CryptoScreener()

    print("üìä Fetching cryptocurrency data...")
    crypto_data = screener.get_top_cryptos(limit=150)

    if not crypto_data:
        print("‚ùå Failed to fetch data. Please try again later.")
        return

    # Create DataFrame
    df = pd.DataFrame(crypto_data)

    # Calculate additional metrics
    df = screener.calculate_volume_ratios(df)

    print(f"‚úÖ Successfully analyzed {len(df)} cryptocurrencies")
    return df, screener

# Run the screener
df, screener = run_screener()

# Display basic statistics
print("üìà SCREENING RESULTS SUMMARY")
print("=" * 50)
print(f"Total Cryptocurrencies Analyzed: {len(df)}")
print(f"Total Market Cap: ${df['market_cap'].sum():,.0f}")
print(f"Total 24h Volume: ${df['total_volume'].sum():,.0f}")
print(f"Average Volume/MCap Ratio: {df['volume_mcap_ratio'].mean():.4f}")
print("=" * 50)

# 1. TOP COINS BY 24H VOLUME
print("üî• TOP 10 COINS BY 24H VOLUME")
print("=" * 60)
top_volume = df.nlargest(10, 'total_volume')[['name', 'symbol', 'total_volume', 'price_change_percentage_24h', 'market_cap']]

for idx, row in top_volume.iterrows():
    vol_billions = row['total_volume'] / 1e9
    mcap_billions = row['market_cap'] / 1e9
    change_24h = row['price_change_percentage_24h']
    change_emoji = "üü¢" if change_24h > 0 else "üî¥"

    print(f"{idx + 1:2d}. {row['name']:15} ({row['symbol'].upper():6}) "
          f"| Vol: ${vol_billions:5.2f}B | 24h: {change_emoji} {change_24h:6.2f}% "
          f"| MCap: ${mcap_billions:5.1f}B")

display(top_volume.style.format({
    'total_volume': '${:,.0f}',
    'market_cap': '${:,.0f}',
    'price_change_percentage_24h': '{:.2f}%'
}).background_gradient(subset=['total_volume'], cmap='Greens'))

# 2. TOP COINS BY VOLUME TO MARKET CAP RATIO
print("üìä TOP 10 COINS BY VOLUME/MCAP RATIO (High Velocity)")
print("=" * 70)
top_ratio = df.nlargest(10, 'volume_mcap_ratio')[['name', 'symbol', 'volume_mcap_ratio', 'total_volume', 'market_cap']]

for idx, row in top_ratio.iterrows():
    ratio_pct = row['volume_mcap_ratio'] * 100
    vol_millions = row['total_volume'] / 1e6
    mcap_millions = row['market_cap'] / 1e6

    print(f"{idx + 1:2d}. {row['name']:20} ({row['symbol'].upper():6}) "
          f"| Ratio: {ratio_pct:6.2f}% | Vol: ${vol_millions:7.1f}M "
          f"| MCap: ${mcap_millions:7.1f}M")

display(top_ratio.style.format({
    'volume_mcap_ratio': '{:.4f}',
    'total_volume': '${:,.0f}',
    'market_cap': '${:,.0f}'
}).background_gradient(subset=['volume_mcap_ratio'], cmap='Blues'))

# 3. MULTI-TIMEFRAME PERFORMANCE ANALYSIS
print("üïê MULTI-TIMEFRAME PERFORMANCE LEADERS")
print("=" * 80)

# Create timeframe analysis
timeframes = ['1h', '24h', '7d', '30d']
timeframe_columns = [f'price_change_percentage_{tf}' for tf in timeframes]

for i, (tf, col) in enumerate(zip(timeframes, timeframe_columns)):
    print(f"\nüèÜ TOP 5 PERFORMERS - LAST {tf.upper()}:")
    top_performers = df.nlargest(5, col)[['name', 'symbol', col, 'total_volume']]

    for idx, row in top_performers.iterrows():
        change = row[col]
        vol_millions = row['total_volume'] / 1e6
        emoji = "üöÄ" if change > 20 else "üü¢" if change > 0 else "üî¥"

        print(f"   {idx + 1:2d}. {row['name']:15} ({row['symbol'].upper():6}) "
              f"| {emoji} {change:6.2f}% | Vol: ${vol_millions:6.1f}M")

# 4. COMPREHENSIVE SCORING TABLE
print("üéØ COMPREHENSIVE CRYPTO SCREENING RESULTS")
print("=" * 90)

# Create final ranked dataframe
ranked_df = df.copy()
ranked_df['volume_rank'] = ranked_df['total_volume'].rank(ascending=False)
ranked_df['ratio_rank'] = ranked_df['volume_mcap_ratio'].rank(ascending=False)
ranked_df['overall_rank'] = ranked_df['overall_score'].rank(ascending=False)

# Display top 20 overall
top_overall = ranked_df.nsmallest(20, 'overall_rank')[[
    'name', 'symbol', 'total_volume', 'market_cap', 'volume_mcap_ratio',
    'price_change_percentage_24h', 'overall_score', 'volume_rank', 'ratio_rank'
]]

formatted_table = top_overall.style.format({
    'total_volume': '${:,.0f}',
    'market_cap': '${:,.0f}',
    'volume_mcap_ratio': '{:.4f}',
    'price_change_percentage_24h': '{:.2f}%',
    'overall_score': '{:.1f}'
}).background_gradient(subset=['total_volume'], cmap='Greens')\
  .background_gradient(subset=['volume_mcap_ratio'], cmap='Blues')\
  .background_gradient(subset=['overall_score'], cmap='Purples')

display(formatted_table)

# 5. VISUALIZATION DASHBOARD
def create_visualizations(df):
    """Create interactive visualizations for the screening results"""

    # Filter for better visualization (remove extreme outliers)
    viz_df = df[df['total_volume'] > 1e6].copy()

    # Create subplots
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=(
            'Volume vs Market Cap (Size = 24h Change)',
            'Top 15 Cryptos by 24h Volume',
            'Volume to Market Cap Ratio Distribution',
            'Best Overall Scores (Volume + Ratio)'
        ),
        specs=[[{"secondary_y": False}, {"secondary_y": False}],
               [{"secondary_y": False}, {"secondary_y": False}]]
    )

    # Plot 1: Volume vs Market Cap Bubble Chart
    top_30 = viz_df.nlargest(30, 'total_volume')
    fig.add_trace(
        go.Scatter(
            x=top_30['market_cap'],
            y=top_30['total_volume'],
            mode='markers+text',
            marker=dict(
                size=np.log(top_30['price_change_percentage_24h'].abs() + 1) * 10,
                color=top_30['price_change_percentage_24h'],
                colorscale='RdYlGn',
                colorbar=dict(title="24h Change %"),
                showscale=True
            ),
            text=top_30['symbol'].str.upper(),
            textposition="middle center",
            hovertemplate="<b>%{text}</b><br>"
                        "Market Cap: $%{x:,.0f}<br>"
                        "Volume: $%{y:,.0f}<br>"
                        "24h Change: %{marker.color:.2f}%<extra></extra>"
        ),
        row=1, col=1
    )

    # Plot 2: Top 15 by Volume
    top_15_volume = viz_df.nlargest(15, 'total_volume')
    fig.add_trace(
        go.Bar(
            x=top_15_volume['symbol'].str.upper(),
            y=top_15_volume['total_volume'],
            marker_color='lightgreen',
            hovertemplate="<b>%{x}</b><br>Volume: $%{y:,.0f}<extra></extra>"
        ),
        row=1, col=2
    )

    # Plot 3: Volume/MCap Ratio
    top_15_ratio = viz_df.nlargest(15, 'volume_mcap_ratio')
    fig.add_trace(
        go.Bar(
            x=top_15_ratio['symbol'].str.upper(),
            y=top_15_ratio['volume_mcap_ratio'] * 100,
            marker_color='lightblue',
            hovertemplate="<b>%{x}</b><br>Ratio: %{y:.2f}%<extra></extra>"
        ),
        row=2, col=1
    )

    # Plot 4: Overall Scores
    top_15_overall = viz_df.nlargest(15, 'overall_score')
    fig.add_trace(
        go.Bar(
            x=top_15_overall['symbol'].str.upper(),
            y=top_15_overall['overall_score'],
            marker_color='plum',
            hovertemplate="<b>%{x}</b><br>Score: %{y:.1f}<extra></extra>"
        ),
        row=2, col=2
    )

    # Update layout
    fig.update_layout(
        height=800,
        showlegend=False,
        title_text="Crypto Screening Dashboard - Volume & Momentum Analysis",
        title_x=0.5
    )

    # Update axes
    fig.update_xaxes(title_text="Market Cap (USD)", type="log", row=1, col=1)
    fig.update_yaxes(title_text="24h Volume (USD)", type="log", row=1, col=1)
    fig.update_xaxes(title_text="Cryptocurrency", row=1, col=2)
    fig.update_yaxes(title_text="24h Volume (USD)", row=1, col=2)
    fig.update_xaxes(title_text="Cryptocurrency", row=2, col=1)
    fig.update_yaxes(title_text="Volume/MCap Ratio (%)", row=2, col=1)
    fig.update_xaxes(title_text="Cryptocurrency", row=2, col=2)
    fig.update_yaxes(title_text="Overall Score", row=2, col=2)

    fig.show()

# Create visualizations
print("üìä GENERATING INTERACTIVE DASHBOARD...")
create_visualizations(df)

# 6. EXPORT RESULTS
def export_results(df):
    """Export screening results to CSV"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M")
    filename = f"crypto_screening_{timestamp}.csv"

    # Create export dataframe
    export_df = df[[
        'name', 'symbol', 'current_price', 'total_volume', 'market_cap',
        'volume_mcap_ratio', 'price_change_percentage_24h',
        'price_change_percentage_7d', 'price_change_percentage_30d',
        'overall_score', 'volume_rank', 'ratio_rank', 'overall_rank'
    ]].copy()

    # Sort by overall rank
    export_df = export_df.sort_values('overall_rank')

    # Save to CSV
    export_df.to_csv(filename, index=False)
    print(f"üíæ Results exported to: {filename}")

    # Display download link in Colab
    from google.colab import files
    files.download(filename)

    return export_df

# Export results
print("\nüíæ EXPORTING RESULTS...")
export_df = export_results(df)
print("‚úÖ Export completed!")

# 7. REAL-TIME MONITORING SETUP (Optional)
def setup_monitoring():
    """Set up for periodic monitoring"""
    print("\nüîî MONITORING SETUP")
    print("=" * 50)
    print("To set up automatic monitoring:")
    print("1. Run this cell every hour for updated screening")
    print("2. Track changes in volume rankings over time")
    print("3. Monitor volume/MCap ratio for unusual activity")
    print("4. Watch for coins moving up in overall rankings")
    print("\nTop 5 coins to watch closely:")

    watchlist = df.nsmallest(5, 'overall_rank')[['name', 'symbol', 'overall_score']]
    for idx, row in watchlist.iterrows():
        print(f"   üëÅÔ∏è  {row['name']} ({row['symbol'].upper()}) - Score: {row['overall_score']:.1f}")

setup_monitoring()